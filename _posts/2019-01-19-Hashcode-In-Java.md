---
layout:     post
title:      Hashcode in Java
subtitle:   The importance of hashcode method and how to override
date:       2019-01-19
author:     Mr.Humorous ü•ò
header-img: img/java/header.jpg
catalog: true
tags:
    - Java
---

## 1. Overview
Hashing is a fundamental concept of computer science. The full example code is on [Github](https://github.com/eugenp/tutorials/tree/master/core-java-lang-oop).

In Java, efficient hashing algorithms stand behind some of the most popular collections we have available ‚Äì such as the [HashMap](https://www.baeldung.com/java-hashmap) and the [HashSet](https://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html).

## 2. Usage of hashCode() in Data Structures
The simplest operations on collections can be inefficient in certain situations.

For example, this triggers a linear search which is highly ineffective for lists of huge sizes:
```java
List<String> words = Arrays.asList("Welcome", "to", "Baeldung");
if (words.contains("Baeldung")) {
    System.out.println("Baeldung is in the list");
}
```

Java provides a number of data structures for dealing with this issue specifically ‚Äì for example, several Map interface implementations are [hash tables](https://en.wikipedia.org/wiki/Hash_table).

When using a hash table, __these collections calculate the hash value for a given key using the hashCode() method and use this value internally to store the data__ ‚Äì so that access operations are much more efficient.

## 3. Understanding How hashCode() Works
Simply put, _hashCode()_ returns an integer value, generated by a hashing algorithm.

Objects that are equal (according to their equals()) must return the same hash code. __It‚Äôs not required for different objects to return different hash codes__.

The general contract of hashCode() states:
- Whenever it is invoked on the same object more than once during an execution of a Java application, hashCode() must consistently return the same value, provided no information used in equals comparisons on the object is modified. This value needs not remain consistent from one execution of an application to another execution of the same application
- If two objects are equal according to the equals(Object) method, then calling the hashCode() method on each of the two objects must produce the same value
- It is not required that if two objects are unequal according to the [equals(java.lang.Object)](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals%28java.lang.Object%29) method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, developers should be aware that producing distinct integer results for unequal objects improves the performance of hash tables
> ‚ÄúAs much as is reasonably practical, the hashCode() method defined by class Object does return distinct integers for distinct objects. (This is typically implemented by converting the internal address of the object into an integer, but this implementation technique is not required by the JavaTM programming language.)‚Äù

## 4. A Naive hashCode() Implementation
It‚Äôs actually quite straightforward to have a naive hashCode() implementation that fully adheres to the above contract.

To demonstrate this, we‚Äôre going to define a sample User class that overrides the method‚Äôs default implementation:
```java
public class User {

    private long id;
    private String name;
    private String email;

    // standard getters/setters/constructors

    @Override
    public int hashCode() {
        return 1;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null) return false;
        if (this.getClass() != o.getClass()) return false;
        User user = (User) o;
        return id == user.id
          && (name.equals(user.name)
          && email.equals(user.email));
    }

    // getters and setters here
}
```

The User class provides custom implementations for both equals() and hashCode() that fully adhere to the respective contracts. Even more, there‚Äôs nothing illegitimate with having hashCode() returning any fixed value.

__However, this implementation degrades the functionality of hash tables to basically zero, as every object would be stored in the same, single bucket__.

In this context, a hash table lookup is performed linearly and does not give us any real advantage ‚Äì more on this in section 7.

## 5. Improving the hashCode() Implementation
Let‚Äôs improve a little bit the current _hashCode()_ implementation by including all fields of the _User_ class so that it can produce different results for unequal objects:
```java
@Override
public int hashCode() {
    return (int) id * name.hashCode() * email.hashCode();
}
```

This basic hashing algorithm is definitively much better than the previous one, as it computes the object‚Äôs hash code by just multiplying the hash codes of the name and email fields and the id.

In general terms, we can say that this is a reasonable hashCode() implementation, as long as we keep the equals() implementation consistent with it.

## 6. Standard hashCode() Implementations
The better the hashing algorithm that we use to compute hash codes, the better will the performance of hash tables be.

Let‚Äôs have a look at a ‚Äústandard‚Äù implementation that uses two primes numbers to add even more uniqueness to computed hash codes:
```java
@Override
public int hashCode() {
    int hash = 7;
    hash = 31 * hash + (int) id;
    hash = 31 * hash + (name == null ? 0 : name.hashCode());
    hash = 31 * hash + (email == null ? 0 : email.hashCode());
    return hash;
}
```

While it‚Äôs essential to understand the roles that hashCode() and equals() methods play, we don‚Äôt have to implement them from scratch every time, as most IDEs can generate custom hashCode() and equals() implementations and since Java 7, we got an Objects.hash() utility method for comfortable hashing:
```java
Objects.hash(name, email)
```

<u>IntelliJ</u> IDEA generates the following implementation:
```java
@Override
public int hashCode() {
    int result = (int) (id ^ (id >>> 32));
    result = 31 * result + name.hashCode();
    result = 31 * result + email.hashCode();
    return result;
}
```

And <u>Eclipse</u> produces this one:
```java
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((email == null) ? 0 : email.hashCode());
    result = prime * result + (int) (id ^ (id >>> 32));
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    return result;
}
```

In addition to the above IDE-based hashCode() implementations, it‚Äôs also possible to automatically generate an efficient implementation, for example using <u>Lombok</u>. In this case, the lombok-maven dependency must be added to pom.xml:
```xml
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok-maven</artifactId>
    <version>1.16.18.0</version>
    <type>pom</type>
</dependency>
```

It‚Äôs now enough to annotate the User class with @EqualsAndHashCode:
```java
@EqualsAndHashCode
public class User {
    // fields and methods here
}
```

Similarly, if we want <u>Apache Commons Lang‚Äôs HashCodeBuilder class</u> to generate a hashCode() implementation for us, the commons-lang Maven dependency must be included in the pom file:
```xml
<dependency>
    <groupId>commons-lang</groupId>
    <artifactId>commons-lang</artifactId>
    <version>2.6</version>
</dependency>
```

And hashCode() can be implemented like this:
```java
public class User {
    public int hashCode() {
        return new HashCodeBuilder(17, 37).
        append(id).
        append(name).
        append(email).
        toHashCode();
    }
}
```

In general, there‚Äôs no universal recipe to stick to when it comes to implementing hashCode(). We highly recommend reading _Joshua Bloch‚Äôs Effective Java_, which provides a list of thorough guidelines for implementing _efficient hashing algorithms_.

What can be noticed here is that all those implementations utilize number 31 in some form ‚Äì this is because 31 has a nice property ‚Äì its multiplication can be replaced by a bitwise shift which is faster than the standard multiplication:
```java
31 * i == (i << 5) - i
```

## 7. Handling Hash Collisions
The intrinsic behavior of hash tables raises up a relevant aspect of these data structures: even with an efficient hashing algorithm, two or more objects might have the same hash code, even if they‚Äôre unequal. So, their hash codes would point to the same bucket, even though they would have different hash table keys.

This situation is commonly known as a hash collision, and various methodologies exist for handling it, with each one having their pros and cons. Java‚Äôs HashMap uses the [separate chaining method](https://en.wikipedia.org/wiki/Hash_table#Separate_chaining_with_linked_lists) for handling collisions:

__‚ÄúWhen two or more objects point to the same bucket, they‚Äôre simply stored in a linked list. In such a case, the hash table is an array of linked lists, and each object with the same hash is appended to the linked list at the bucket index in the array.__

__In the worst case, several buckets would have a linked list bound to it, and the retrieval of an object in the list would be performed linearly.‚Äù__

Hash collision methodologies show in a nutshell why it‚Äôs so important to implement hashCode() efficiently.

Java 8 brought an interesting [enhancement to HashMap implementation](http://openjdk.java.net/jeps/180) ‚Äì if a bucket size goes beyond the certain threshold, the linked list gets replaced with a tree map. This allows achieving O(logn) look up instead of pessimistic O(n).

## 8. Creating a Trivial Application
To test the functionality of a standard hashCode() implementation, let‚Äôs create a simple Java application that adds some User objects to a HashMap and uses SLF4J for logging a message to the console each time the method is called.

Here‚Äôs the sample application‚Äôs entry point:
```java
public class Application {

    public static void main(String[] args) {
        Map<User, User> users = new HashMap<>();
        User user1 = new User(1L, "John", "john@domain.com");
        User user2 = new User(2L, "Jennifer", "jennifer@domain.com");
        User user3 = new User(3L, "Mary", "mary@domain.com");

        users.put(user1, user1);
        users.put(user2, user2);
        users.put(user3, user3);
        if (users.containsKey(user1)) {
            System.out.print("User found in the collection");
        }
    }
}
```

And this is the hashCode() implementation:
```java
public class User {

    // ...

    public int hashCode() {
        int hash = 7;
        hash = 31 * hash + (int) id;
        hash = 31 * hash + (name == null ? 0 : name.hashCode());
        hash = 31 * hash + (email == null ? 0 : email.hashCode());
        logger.info("hashCode() called - Computed hash: " + hash);
        return hash;
    }
}
```

The only detail worth stressing here is that each time an object is stored in the hash map and checked with the containsKey() method, hashCode() is invoked and the computed hash code is printed out to the console:
```
[main] INFO com.baeldung.entities.User - hashCode() called - Computed hash: 1255477819
[main] INFO com.baeldung.entities.User - hashCode() called - Computed hash: -282948472
[main] INFO com.baeldung.entities.User - hashCode() called - Computed hash: -1540702691
[main] INFO com.baeldung.entities.User - hashCode() called - Computed hash: 1255477819
User found in the collection
```
